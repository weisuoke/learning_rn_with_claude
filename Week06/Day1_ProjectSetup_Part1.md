# React Native入门 - 第1天：项目架构与工程化设置 | React Native Introduction - Day 1: Project Architecture & Engineering Setup

## 学习目标 | Learning Objectives
- 掌握使用Expo CLI创建和配置专业级React Native项目 | Master creating and configuring professional React Native projects using Expo CLI
- 理解React Native项目的文件夹结构设计原则和最佳实践 | Understand folder structure design principles and best practices for React Native projects
- 学会安装和配置React Navigation的核心导航库 | Learn to install and configure core React Navigation libraries
- 掌握项目架构规划，包括导航层级和屏幕组织 | Master project architecture planning, including navigation hierarchy and screen organization
- 理解设计系统基础，创建主题常量和样式指南 | Understand design system fundamentals and create theme constants and style guidelines
- 学会集成第三方API服务并管理API密钥 | Learn to integrate third-party API services and manage API keys

## 详细内容 | Detailed Content

### 1. Expo项目初始化与依赖管理 | Expo Project Initialization & Dependency Management (1小时 | 1 hour)

- **Expo CLI与项目创建 | Expo CLI and Project Creation**

  **概念定义 | Concept Definition:**
  Expo CLI是React Native开发的命令行工具，提供了项目脚手架、开发服务器、构建工具和部署服务的完整解决方案。与传统React Native CLI相比，Expo提供了开箱即用的原生功能和更简化的配置流程，特别适合快速原型开发和中小型生产应用。| Expo CLI is a command-line tool for React Native development that provides a complete solution including project scaffolding, development server, build tools, and deployment services. Compared to traditional React Native CLI, Expo offers out-of-the-box native features and a more simplified configuration process, especially suitable for rapid prototyping and small to medium-sized production applications.

  **核心特征 | Key Characteristics:**
  - Expo管理了所有原生依赖，开发者无需直接配置Xcode或Android Studio | Expo manages all native dependencies, developers don't need to directly configure Xcode or Android Studio
  - 提供了Expo Go应用，允许在真机上即时预览而无需构建原生代码 | Provides Expo Go app for instant preview on physical devices without building native code
  - 包含丰富的原生API库（相机、位置、通知等），通过JavaScript接口访问 | Includes rich native API libraries (camera, location, notifications, etc.) accessible through JavaScript interfaces
  - 支持OTA（Over-The-Air）更新，可以在不重新发布应用的情况下推送代码更新 | Supports OTA (Over-The-Air) updates to push code changes without republishing the app
  - 提供EAS（Expo Application Services）用于云端构建和发布 | Provides EAS (Expo Application Services) for cloud-based builds and distribution

  **概念检查问题 | Concept Checking Questions (CCQs):**
  1. Expo项目可以访问设备的原生功能（如相机、GPS）吗？| Can Expo projects access native device features (like camera, GPS)?
     **答案 | Answer:** 是 | Yes - Expo提供了预构建的原生模块，通过expo-camera、expo-location等包即可访问 | Expo provides pre-built native modules accessible through packages like expo-camera, expo-location
  2. 使用Expo创建的项目能否在没有网络连接的情况下运行？| Can projects created with Expo run without network connectivity?
     **答案 | Answer:** 是 | Yes - 一旦应用构建完成或在开发环境中加载，应用本身不需要网络即可运行（除非应用功能依赖网络数据）| Once the app is built or loaded in the development environment, the app itself doesn't require network to run (unless app features depend on network data)
  3. Expo CLI生成的项目结构中，App.js是必需的入口文件吗？| Is App.js a required entry file in the project structure generated by Expo CLI?
     **答案 | Answer:** 是 | Yes - App.js是Expo项目的默认入口点，由app.json中的main字段指定（默认为"expo/AppEntry.js"，它会加载App.js）| App.js is the default entry point for Expo projects, specified by the main field in app.json (defaults to "expo/AppEntry.js" which loads App.js)
  4. 在Expo项目中，必须使用Expo提供的所有功能吗？| In an Expo project, must you use all features provided by Expo?
     **答案 | Answer:** 否 | No - Expo功能是模块化的，开发者可以选择性地安装和使用需要的包 | Expo features are modular, developers can selectively install and use the packages they need

  **代码示例与验证 | Code Examples and Verification:**
  ```bash
  # 创建新的Expo项目 | Create a new Expo project
  npx create-expo-app NewsReader

  # 进入项目目录 | Navigate to project directory
  cd NewsReader

  # 启动开发服务器 | Start development server
  npx expo start

  # 查看项目结构 | View project structure
  ls -la
  # 预期输出: | Expected output:
  # - App.js (应用入口 | app entry)
  # - app.json (Expo配置 | Expo configuration)
  # - package.json (依赖管理 | dependency management)
  # - node_modules/ (依赖包 | dependencies)
  # - assets/ (静态资源 | static assets)
  ```

  **实践检查问题 | Practice Checking Questions:**
  - 运行`npx create-expo-app NewsReader`后会生成哪些核心文件？| What core files are generated after running `npx create-expo-app NewsReader`?
    **答案 | Answer:** App.js (入口文件), app.json (配置文件), package.json (依赖配置), babel.config.js (Babel配置) | App.js (entry file), app.json (configuration), package.json (dependencies), babel.config.js (Babel config)
  - 如果运行`npx expo start`后无法启动，最可能的原因是什么？| If `npx expo start` fails to launch, what's the most likely cause?
    **答案 | Answer:** 端口冲突（默认19000、19001已被占用）或node_modules未正确安装（需运行npm install）| Port conflict (default ports 19000, 19001 already in use) or node_modules not properly installed (need to run npm install)

  **常见误区检查 | Common Misconception Checks:**
  - Expo项目就是一个纯JavaScript项目，不包含任何原生代码吗？| Are Expo projects purely JavaScript projects without any native code?
    **答案 | Answer:** 错误 | Incorrect - Expo项目包含原生代码，只是这些代码由Expo预先构建和管理，开发者通常不需要直接修改它们。使用expo prebuild可以生成原生代码目录（ios/和android/）| Expo projects do contain native code, but it's pre-built and managed by Expo. Developers typically don't need to modify it directly. You can generate native code directories (ios/ and android/) using expo prebuild
  - 使用Expo就无法添加自定义原生模块了吗？| Does using Expo mean you can't add custom native modules?
    **答案 | Answer:** 错误 | Incorrect - Expo支持通过"expo prebuild"命令切换到"bare workflow"，这样可以添加任何React Native原生模块，同时保留Expo的大部分功能 | Expo supports switching to "bare workflow" via "expo prebuild" command, allowing you to add any React Native native modules while retaining most Expo features

- **依赖包安装与版本管理 | Dependency Installation & Version Management**

  **概念定义 | Concept Definition:**
  依赖管理是指在项目中引入、更新和维护第三方库的过程。在React Native项目中，需要特别注意原生依赖的版本兼容性，因为不同版本的React Navigation、Expo SDK和React Native可能存在不兼容问题。| Dependency management refers to the process of introducing, updating, and maintaining third-party libraries in a project. In React Native projects, special attention must be paid to version compatibility of native dependencies, as different versions of React Navigation, Expo SDK, and React Native may have incompatibility issues.

  **核心特征 | Key Characteristics:**
  - package.json中的dependencies定义了生产环境所需的包 | dependencies in package.json define packages required for production
  - devDependencies包含仅在开发时需要的工具（如TypeScript、ESLint）| devDependencies contain tools needed only during development (like TypeScript, ESLint)
  - peerDependencies指明了当前包需要的宿主环境版本（如React Native版本）| peerDependencies indicate the required host environment version (like React Native version)
  - React Navigation v6需要安装多个互相依赖的包才能工作 | React Navigation v6 requires installing multiple interdependent packages to work
  - Expo SDK版本会锁定兼容的React Native版本 | Expo SDK version locks compatible React Native versions

  **概念检查问题 | Concept Checking Questions (CCQs):**
  1. 安装React Navigation时，只需要安装@react-navigation/native一个包就足够了吗？| When installing React Navigation, is it sufficient to install only @react-navigation/native?
     **答案 | Answer:** 否 | No - 还需要安装依赖包（react-native-screens、react-native-safe-area-context等）和具体的导航器（如@react-navigation/stack、@react-navigation/bottom-tabs）| Additional dependencies (react-native-screens, react-native-safe-area-context, etc.) and specific navigators (@react-navigation/stack, @react-navigation/bottom-tabs) are also required
  2. 在Expo项目中，可以使用npm和yarn混合安装依赖吗？| In an Expo project, can you use both npm and yarn to install dependencies?
     **答案 | Answer:** 不推荐 | Not recommended - 应该统一使用一种包管理器，避免lockfile冲突（package-lock.json vs yarn.lock），否则可能导致依赖版本不一致 | Should use one package manager consistently to avoid lockfile conflicts (package-lock.json vs yarn.lock), otherwise may lead to dependency version inconsistencies
  3. axios和fetch都可以用来进行API调用，它们可以同时安装在一个项目中吗？| Both axios and fetch can be used for API calls, can they be installed in the same project?
     **答案 | Answer:** 可以 | Yes - 它们可以共存，但为了代码一致性，通常选择一种作为项目的标准HTTP客户端。fetch是浏览器和React Native的内置API，不需要安装；axios需要额外安装但提供更丰富的功能 | They can coexist, but for code consistency, typically one is chosen as the project's standard HTTP client. fetch is built into browsers and React Native; axios requires installation but provides richer features
  4. 如果package.json中的版本号前有^符号（如^6.0.0），表示什么？| If a version number in package.json has a ^ symbol (like ^6.0.0), what does it mean?
     **答案 | Answer:** 兼容更新 | Compatible updates - ^6.0.0表示可以自动更新到6.x.x的任何次要版本和补丁版本，但不会更新到7.0.0（主版本锁定）| ^6.0.0 means it can auto-update to any minor and patch version in 6.x.x, but won't update to 7.0.0 (major version locked)

  **代码示例与验证 | Code Examples and Verification:**
  ```bash
  # 在NewsReader项目中安装React Navigation核心依赖 | Install React Navigation core dependencies in NewsReader project
  npx expo install @react-navigation/native @react-navigation/stack @react-navigation/bottom-tabs

  # 安装React Navigation所需的原生依赖（Expo会自动选择兼容版本）| Install native dependencies required by React Navigation (Expo auto-selects compatible versions)
  npx expo install react-native-screens react-native-safe-area-context

  # 安装HTTP客户端（选择axios或使用内置的fetch）| Install HTTP client (choose axios or use built-in fetch)
  npm install axios

  # 验证安装 | Verify installation
  npm list --depth=0
  # 预期看到: | Expected to see:
  # ├── @react-navigation/bottom-tabs@^6.x.x
  # ├── @react-navigation/native@^6.x.x
  # ├── @react-navigation/stack@^6.x.x
  # ├── axios@^1.x.x
  # ├── expo@~49.x.x (版本号根据创建时间可能不同 | version may vary based on creation time)
  # └── react-native-screens@^3.x.x
  ```

  ```json
  // package.json中的依赖部分应该类似这样 | Dependencies section in package.json should look like this
  {
    "dependencies": {
      "@react-navigation/bottom-tabs": "^6.5.11",
      "@react-navigation/native": "^6.1.9",
      "@react-navigation/stack": "^6.3.20",
      "axios": "^1.6.2",
      "expo": "~49.0.15",
      "react": "18.2.0",
      "react-native": "0.72.6",
      "react-native-safe-area-context": "4.6.3",
      "react-native-screens": "~3.22.0"
    }
  }
  ```

  **实践检查问题 | Practice Checking Questions:**
  - 如果运行`npx expo install`而不是`npm install`来安装React Navigation依赖，有什么区别？| What's the difference between using `npx expo install` vs `npm install` for React Navigation dependencies?
    **答案 | Answer:** `npx expo install`会自动选择与当前Expo SDK版本兼容的包版本，避免版本冲突；`npm install`则安装最新版本，可能导致不兼容 | `npx expo install` automatically selects package versions compatible with current Expo SDK version, avoiding conflicts; `npm install` installs latest versions which may cause incompatibilities
  - 安装依赖后，为什么有时需要清除缓存并重启Metro bundler？| Why is it sometimes necessary to clear cache and restart Metro bundler after installing dependencies?
    **答案 | Answer:** Metro bundler会缓存模块解析结果，新安装的原生依赖可能需要清除缓存才能被正确识别，使用`npx expo start -c`可以清除缓存启动 | Metro bundler caches module resolution results; newly installed native dependencies may require cache clearing to be properly recognized, use `npx expo start -c` to start with cleared cache

  **常见误区检查 | Common Misconception Checks:**
  - 安装了React Navigation后，应用会自动有导航功能了吗？| After installing React Navigation, does the app automatically have navigation functionality?
    **答案 | Answer:** 否 | No - 仅安装依赖包不会自动添加导航，需要在代码中配置NavigationContainer和创建导航器组件 | Just installing dependency packages doesn't automatically add navigation; you need to configure NavigationContainer and create navigator components in code
  - 每次项目中添加新依赖，都需要重新构建原生代码吗？| Every time you add new dependencies to the project, do you need to rebuild native code?
    **答案 | Answer:** 在Expo管理的工作流中通常不需要 | Usually not in Expo-managed workflow - Expo管理的原生模块不需要重新构建。但如果使用expo prebuild转换为bare workflow后添加原生模块，则需要重新构建 | Native modules managed by Expo don't require rebuilding. However, if you convert to bare workflow using expo prebuild and add native modules, rebuilding is required

### 2. 项目文件夹结构设计 | Project Folder Structure Design (45分钟 | 45 minutes)

- **模块化架构原则 | Modular Architecture Principles**

  **概念定义 | Concept Definition:**
  模块化架构是将应用分解为功能独立、职责单一的模块的设计方法。在React Native项目中，良好的文件夹结构应该清晰地分离关注点（Separation of Concerns），使得UI组件、业务逻辑、数据获取、导航配置等各司其职，提高代码的可维护性和可测试性。| Modular architecture is a design approach that decomposes an application into functionally independent, single-responsibility modules. In React Native projects, a good folder structure should clearly separate concerns, allowing UI components, business logic, data fetching, and navigation configuration to have distinct responsibilities, improving code maintainability and testability.

  **核心特征 | Key Characteristics:**
  - **关注点分离**：UI展示、状态管理、API调用、工具函数分别放在不同目录 | **Separation of Concerns**: UI presentation, state management, API calls, utility functions are placed in different directories
  - **可预测性**：开发者能根据功能类型快速定位文件位置 | **Predictability**: Developers can quickly locate files based on functionality type
  - **可扩展性**：添加新功能时不会破坏现有结构 | **Scalability**: Adding new features doesn't break existing structure
  - **组件复用**：共享组件放在独立目录，避免重复代码 | **Component Reusability**: Shared components placed in separate directory to avoid code duplication
  - **平台特定代码**：通过.ios.js和.android.js后缀分离平台代码 | **Platform-specific Code**: Separate platform code using .ios.js and .android.js suffixes

  **概念检查问题 | Concept Checking Questions (CCQs):**
  1. 将所有组件都放在一个components文件夹中，是否符合模块化原则？| Does putting all components in one components folder align with modular principles?
     **答案 | Answer:** 不完全符合 | Not entirely - 更好的做法是区分公共组件（components/）和屏幕级组件（screens/），甚至可以按功能模块进一步细分（如components/articles/、components/bookmarks/）| Better practice is to distinguish between common components (components/) and screen-level components (screens/), or even further subdivide by functional modules (like components/articles/, components/bookmarks/)
  2. /services目录应该包含什么类型的代码？| What type of code should the /services directory contain?
     **答案 | Answer:** API调用逻辑 | API call logic - 与外部服务交互的代码，如HTTP请求函数、数据转换逻辑、错误处理等，但不包含UI或状态管理 | Code that interacts with external services, such as HTTP request functions, data transformation logic, error handling, but not UI or state management
  3. 常量文件（如colors.js）应该放在哪个目录？| Where should constant files (like colors.js) be placed?
     **答案 | Answer:** /constants目录 | /constants directory - 所有硬编码的配置值、主题变量、API端点等应集中管理在这里，便于全局修改 | All hard-coded configuration values, theme variables, API endpoints should be centrally managed here for easy global modification
  4. 如果一个组件只在某个屏幕中使用，应该放在哪里？| If a component is only used in one screen, where should it be placed?
     **答案 | Answer:** 有两种方案 | Two approaches - 方案1：放在该屏幕文件的同级目录（如screens/Home/HomeScreen.js和screens/Home/ArticleCard.js）；方案2：如果文件较小，可以直接写在屏幕文件内部。如果未来可能被复用，则放入components/ | Approach 1: Place in same directory as the screen file (like screens/Home/HomeScreen.js and screens/Home/ArticleCard.js); Approach 2: If file is small, write directly inside screen file. If likely to be reused in future, place in components/

  **代码示例与验证 | Code Examples and Verification:**
  ```bash
  # 在NewsReader项目中创建推荐的文件夹结构 | Create recommended folder structure in NewsReader project
  mkdir -p src/{screens,components,navigation,services,constants,utils,hooks,contexts}

  # 创建子目录以进一步组织代码 | Create subdirectories for further code organization
  mkdir -p src/screens/{Home,ArticleDetail,Categories,Bookmarks,Settings}
  mkdir -p src/components/{common,articles}
  mkdir -p src/constants/{themes}

  # 验证结构 | Verify structure
  tree src -L 2
  # 预期输出: | Expected output:
  # src/
  # ├── components/
  # │   ├── articles/
  # │   └── common/
  # ├── constants/
  # │   └── themes/
  # ├── contexts/
  # ├── hooks/
  # ├── navigation/
  # ├── screens/
  # │   ├── ArticleDetail/
  # │   ├── Bookmarks/
  # │   ├── Categories/
  # │   ├── Home/
  # │   └── Settings/
  # ├── services/
  # └── utils/
  ```

  ```javascript
  // 创建初始的文件以演示结构 | Create initial files to demonstrate structure

  // src/constants/colors.js - 颜色常量 | Color constants
  export const COLORS = {
    primary: '#007AFF',      // iOS蓝色 | iOS blue
    background: '#FFFFFF',   // 背景白色 | Background white
    text: '#000000',         // 文本黑色 | Text black
    gray: '#8E8E93',         // 次要文本 | Secondary text
    error: '#FF3B30',        // 错误红色 | Error red
  };

  // src/constants/typography.js - 字体常量 | Typography constants
  export const FONTS = {
    regular: 'System',
    bold: 'System',
    sizes: {
      small: 12,
      medium: 16,
      large: 20,
      xlarge: 24,
    },
  };

  // src/services/api.js - API服务层 | API service layer
  import axios from 'axios';

  const API_BASE_URL = 'https://newsapi.org/v2';
  // API_KEY将在后续步骤中配置 | API_KEY will be configured in later steps

  export const newsAPI = {
    // 获取头条新闻 | Get top headlines
    getTopHeadlines: async (country = 'us') => {
      // 实现将在Day 2添加 | Implementation to be added in Day 2
    },
  };
  ```

  **实践检查问题 | Practice Checking Questions:**
  - 创建文件夹结构后，App.js应该移动到src目录内吗？| After creating the folder structure, should App.js be moved into the src directory?
    **答案 | Answer:** 可选 | Optional - 有些项目保留App.js在根目录作为入口，导入src/navigation/RootNavigator；也有项目将入口移到src/App.js，然后在根目录的App.js中简单导出。两种方式都可行，保持团队一致即可 | Some projects keep App.js in root as entry, importing src/navigation/RootNavigator; others move entry to src/App.js and simply export from root App.js. Both approaches work, just maintain team consistency
  - 如果需要创建一个自定义Hook（如useArticles），应该放在哪个目录？| If you need to create a custom Hook (like useArticles), which directory should it go in?
    **答案 | Answer:** src/hooks目录 | src/hooks directory - 所有自定义React Hooks（如useDebounce、useArticles、useFetch等）应统一放在这里 | All custom React Hooks (like useDebounce, useArticles, useFetch, etc.) should be uniformly placed here

  **常见误区检查 | Common Misconception Checks:**
  - 文件夹结构越复杂（嵌套越深），项目就越专业吗？| Does a more complex folder structure (deeper nesting) make a project more professional?
    **答案 | Answer:** 否 | No - 过度嵌套会增加导入路径复杂度（如../../../components），降低开发效率。应根据项目规模合理设计，小项目2-3层嵌套足够，大项目可考虑使用别名路径（@components）| Over-nesting increases import path complexity (like ../../../components), reducing development efficiency. Design reasonably based on project scale: 2-3 levels sufficient for small projects, consider path aliases (@components) for large projects
  - /utils和/helpers目录是同一个概念吗？| Are /utils and /helpers directories the same concept?
    **答案 | Answer:** 实践中经常混用 | Often used interchangeably in practice - 但可以区分：utils通常存放纯函数工具（如日期格式化、字符串处理），helpers可能包含更复杂的辅助逻辑（如表单验证、数据转换）。选择一个命名并在项目中保持一致即可 | But can be distinguished: utils typically store pure function utilities (like date formatting, string processing), helpers may contain more complex auxiliary logic (like form validation, data transformation). Choose one naming and keep consistent in the project

- **导航架构设计 | Navigation Architecture Design**

  **概念定义 | Concept Definition:**
  导航架构是定义应用中屏幕之间如何组织和切换的蓝图。在本新闻阅读器应用中，我们采用Bottom Tab Navigator作为主导航，每个Tab内部嵌套Stack Navigator的架构，这种混合导航模式是移动应用的常见模式，既提供了顶层的快速切换（Tab），又支持深层的屏幕导航栈（Stack）。| Navigation architecture is the blueprint defining how screens are organized and transition between each other in an app. In this news reader app, we adopt Bottom Tab Navigator as main navigation, with Stack Navigator nested inside each Tab, a hybrid navigation pattern common in mobile apps that provides both top-level quick switching (Tabs) and deep screen navigation stacks (Stack).

  **核心特征 | Key Characteristics:**
  - **底部标签导航（Bottom Tabs）**：提供4个主要入口点（Home、Categories、Bookmarks、Settings），用户可以快速在这些主功能间切换 | **Bottom Tabs**: Provides 4 main entry points (Home, Categories, Bookmarks, Settings), users can quickly switch between these main functions
  - **堆栈导航（Stack Navigator）**：每个Tab内部维护自己的导航历史栈，支持push/pop操作（如从文章列表进入文章详情）| **Stack Navigator**: Each Tab maintains its own navigation history stack, supporting push/pop operations (like entering article details from article list)
  - **导航状态独立性**：每个Tab的Stack相互独立，切换Tab不会影响其他Tab的导航状态 | **Navigation State Independence**: Each Tab's Stack is independent, switching Tabs doesn't affect other Tabs' navigation state
  - **深度链接准备**：良好的导航架构便于后续实现深度链接（Deep Linking）和状态持久化 | **Deep Link Preparation**: Good navigation architecture facilitates later implementation of deep linking and state persistence

  **概念检查问题 | Concept Checking Questions (CCQs):**
  1. 在Bottom Tab Navigator中，每个Tab可以有多个屏幕吗？| In Bottom Tab Navigator, can each Tab have multiple screens?
     **答案 | Answer:** 是 | Yes - 通过在每个Tab中嵌套Stack Navigator，单个Tab可以包含多个屏幕层级（如Home Tab包含HomeScreen和ArticleDetailScreen）| By nesting Stack Navigator in each Tab, a single Tab can contain multiple screen levels (like Home Tab containing HomeScreen and ArticleDetailScreen)
  2. 用户从Home Tab的ArticleDetailScreen切换到Bookmarks Tab，然后返回Home Tab，会看到什么界面？| If user switches from ArticleDetailScreen in Home Tab to Bookmarks Tab, then returns to Home Tab, what screen do they see?
     **答案 | Answer:** ArticleDetailScreen | ArticleDetailScreen - 每个Tab的导航状态是独立保存的，返回Home Tab会恢复到之前的ArticleDetailScreen而不是HomeScreen | Each Tab's navigation state is independently saved, returning to Home Tab restores to previous ArticleDetailScreen instead of HomeScreen
  3. NavigationContainer必须放在导航器层级的哪个位置？| Where in the navigator hierarchy must NavigationContainer be placed?
     **答案 | Answer:** 最顶层 | Topmost level - NavigationContainer应包裹整个导航器树的根节点，通常在App.js或RootNavigator.js中，一个应用只能有一个NavigationContainer | NavigationContainer should wrap the root node of the entire navigator tree, typically in App.js or RootNavigator.js, only one NavigationContainer per app
  4. 如果Categories Tab中有一个Stack包含CategoryListScreen和CategoryArticlesScreen，当用户点击底部的Categories Tab图标时会发生什么？| If Categories Tab has a Stack containing CategoryListScreen and CategoryArticlesScreen, what happens when user taps the Categories Tab icon in the bottom tab bar?
     **答案 | Answer:** 取决于当前位置 | Depends on current position - 如果用户已在Categories Tab但处于CategoryArticlesScreen，点击Tab图标会回到栈底的CategoryListScreen（popToTop行为，可配置）| If user is already in Categories Tab but on CategoryArticlesScreen, tapping Tab icon returns to stack bottom CategoryListScreen (popToTop behavior, configurable)

  **代码示例与验证 | Code Examples and Verification:**
  ```javascript
  // src/navigation/RootNavigator.js - 根导航器结构规划 | Root navigator structure planning
  import React from 'react';
  import { NavigationContainer } from '@react-navigation/native';
  import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

  // 导入各个Tab的Stack导航器（将在后续创建）| Import Stack navigators for each Tab (to be created later)
  import HomeStack from './HomeStack';
  import CategoriesStack from './CategoriesStack';
  import BookmarksStack from './BookmarksStack';
  import SettingsStack from './SettingsStack';

  const Tab = createBottomTabNavigator();

  /**
   * 根导航器 - 应用的导航入口 | Root Navigator - Navigation entry of the app
   *
   * 架构说明: | Architecture explanation:
   * - 使用Bottom Tab Navigator作为主容器 | Uses Bottom Tab Navigator as main container
   * - 每个Tab对应一个独立的Stack Navigator | Each Tab corresponds to an independent Stack Navigator
   * - 这种嵌套结构允许每个功能模块有自己的导航历史 | This nested structure allows each feature module to have its own navigation history
   */
  export default function RootNavigator() {
    return (
      <NavigationContainer>
        <Tab.Navigator
          screenOptions={{
            headerShown: false, // 隐藏Tab Navigator的默认header，使用各Stack的header | Hide Tab Navigator default header, use each Stack's header
            tabBarActiveTintColor: '#007AFF', // iOS标准蓝色 | iOS standard blue
            tabBarInactiveTintColor: '#8E8E93', // iOS标准灰色 | iOS standard gray
          }}
        >
          {/* Home Tab - 主屏幕和文章详情 | Home Tab - Main screen and article details */}
          <Tab.Screen
            name="HomeTab"
            component={HomeStack}
            options={{
              tabBarLabel: 'Home',
              // tabBarIcon将在Day 6添加 | tabBarIcon to be added in Day 6
            }}
          />

          {/* Categories Tab - 分类浏览 | Categories Tab - Category browsing */}
          <Tab.Screen
            name="CategoriesTab"
            component={CategoriesStack}
            options={{
              tabBarLabel: 'Categories',
            }}
          />

          {/* Bookmarks Tab - 收藏夹 | Bookmarks Tab - Favorites */}
          <Tab.Screen
            name="BookmarksTab"
            component={BookmarksStack}
            options={{
              tabBarLabel: 'Bookmarks',
            }}
          />

          {/* Settings Tab - 设置 | Settings Tab - Settings */}
          <Tab.Screen
            name="SettingsTab"
            component={SettingsStack}
            options={{
              tabBarLabel: 'Settings',
            }}
          />
        </Tab.Navigator>
      </NavigationContainer>
    );
  }
  ```

  ```javascript
  // src/navigation/HomeStack.js - Home Tab的Stack导航器 | Home Tab Stack Navigator
  import React from 'react';
  import { createStackNavigator } from '@react-navigation/stack';

  // 导入屏幕组件（将在后续创建）| Import screen components (to be created later)
  import HomeScreen from '../screens/Home/HomeScreen';
  import ArticleDetailScreen from '../screens/ArticleDetail/ArticleDetailScreen';

  const Stack = createStackNavigator();

  /**
   * Home Stack Navigator
   *
   * 导航层级: | Navigation hierarchy:
   * 1. HomeScreen (栈底) - 显示最新新闻列表 | (Stack bottom) - Shows latest news list
   * 2. ArticleDetailScreen - 显示文章详细内容 | Shows article detailed content
   *
   * 用户流程: 主页 -> 点击文章 -> 查看详情 -> 返回主页 | User flow: Home -> Click article -> View details -> Back to home
   */
  export default function HomeStack() {
    return (
      <Stack.Navigator
        screenOptions={{
          headerStyle: {
            backgroundColor: '#FFFFFF',
          },
          headerTintColor: '#007AFF',
          headerTitleStyle: {
            fontWeight: 'bold',
          },
        }}
      >
        <Stack.Screen
          name="Home"
          component={HomeScreen}
          options={{ title: '今日头条 | Top Headlines' }}
        />
        <Stack.Screen
          name="ArticleDetail"
          component={ArticleDetailScreen}
          options={{
            title: '文章详情 | Article Details',
            // 自定义header按钮将在Day 3添加 | Custom header buttons to be added in Day 3
          }}
        />
      </Stack.Navigator>
    );
  }
  ```

  **实践检查问题 | Practice Checking Questions:**
  - 如果要在Home Tab中添加第三个屏幕（SearchResultsScreen），应该修改哪个文件？| If you want to add a third screen (SearchResultsScreen) in Home Tab, which file should be modified?
    **答案 | Answer:** src/navigation/HomeStack.js - 在Stack.Navigator中添加新的Stack.Screen | Add new Stack.Screen in Stack.Navigator
  - NavigationContainer和Tab.Navigator，哪个应该在外层？| Between NavigationContainer and Tab.Navigator, which should be the outer layer?
    **答案 | Answer:** NavigationContainer在外层 | NavigationContainer is the outer layer - NavigationContainer包裹整个导航树，Tab.Navigator是其子节点 | NavigationContainer wraps entire navigation tree, Tab.Navigator is its child node

  **常见误区检查 | Common Misconception Checks:**
  - 是否每个Stack Navigator都需要自己的NavigationContainer？| Does each Stack Navigator need its own NavigationContainer?
    **答案 | Answer:** 否 | No - 整个应用只需要一个NavigationContainer（在最顶层），所有嵌套的导航器共享这个容器 | Entire app needs only one NavigationContainer (at topmost level), all nested navigators share this container
  - 在Bottom Tab中添加新Tab时，是否必须为其创建Stack Navigator？| When adding a new Tab in Bottom Tab, must you create a Stack Navigator for it?
    **答案 | Answer:** 不是必须 | Not mandatory - 如果Tab只有一个屏幕且不需要导航栈功能，可以直接传递屏幕组件给Tab.Screen。但为了架构一致性和未来扩展性，推荐统一使用Stack | If Tab has only one screen and doesn't need stack functionality, can directly pass screen component to Tab.Screen. But for architecture consistency and future extensibility, recommend uniformly using Stack

